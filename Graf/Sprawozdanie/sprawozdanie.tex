\documentclass[a4paper,11pt]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage{lmodern}
\usepackage{graphicx}

\title{Implementacja grafu oraz algorytmów wyszukujących: DFS i BFS.}
\author{Arkadiusz Cyktor 200367}

\begin{document}
\maketitle


\begin{figure}
  W mojej implementacji grafu użyłem \textbf{macierzy sąsiedztwa} - przechowuje ona informacje o połączeniach pomiędzy poszczególnymi \textbf{wierzchołkami}. Te natomiast tworzone są na bazie struktury "wierzcholek" i umieszczane w odpowiednim  miejscu (pole odpowiadające numerowi wierzchołka) przechowującego ich wektora.
\\Wierzchołki łączone są \textbf{krawędziami}, za kształt których również odpowiada odpowiedznia struktura - "krawedz". Dodając obiekt tego typu określamy jakie dwa wierzchołki ma ze sobą łączyć oraz jaką dane połączenie ma mieć wagę. Podobnie jak wierzchołki, krawędzie również przechowywane są w wektorze.
\\
\\Algorytm wyszukujący \textbf{DFS} porusza się po grafie przy pomocy macierzy sąsiedztwa. Po odwiedzeniu przez algorytm wierzchołek jest odznaczany przez przypisanie wartości true zmiennej ''czy odwiedzony", a następnie wraca on do pozostałych nieodwiedzonych sąsiadów danego wierzchołka - i tak aż do chwili, w której każdy sąsiad zostanie odznaczony jako odwiedzony, wtedy algorytm przechodzi do innego (nieodwiedzonego jeszcze) wierzchołka. Na koniec wyświetlany jest komunikat o odnalezieniu szukanego elememtu, a wszystkie wierzchołki ponownie oznaczane są jako nieodwiedzone.
\\Algorytm \textbf{BFS} również wykorzystuje macierz sąsiedztwa, ale w jego przypadku dochodzi jeszcze kolejka realizowana przez strukturę ''lista BFS". W kolejce tej umieszczane są wierzchołki, które po kolei pobierane są do odczytu i zastępowane przez swoich nieodwiedzonych sąsiadów. Po odwiedzeniu przez algorytm wierzchołek jest odznaczany. Na koniec wyświetlany jest komunikat o odnalezieniu szukanego elememtu, a wszystkie wierzchołki ponownie oznaczane są jako nieodwiedzone.
\end{figure}
\end{document}